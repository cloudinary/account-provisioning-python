"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cloudinary_account_provisioning.types import BaseModel, UNSET_SENTINEL
from cloudinary_account_provisioning.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
)
from datetime import date
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GetUsersGlobalsTypedDict(TypedDict):
    account_id: NotRequired[str]
    r"""Account ID"""


class GetUsersGlobals(BaseModel):
    account_id: Annotated[
        Optional[str],
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ] = None
    r"""Account ID"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["account_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UnionType(str, Enum):
    r"""Whether to return users who last logged in within the specified date range (include) or those who didn't
    last log in within the range (exclude). **Possible values**: `include`, `exclude`. **Default**: `include`.

    """

    INCLUDE = "include"
    EXCLUDE = "exclude"


class QueryParamSortOrder(str, Enum):
    r"""Control the order of returned users. **Possible values**: `desc` (default), `asc`."""

    DESC = "desc"
    ASC = "asc"


class QueryParamSortBy(str, Enum):
    NAME = "name"
    ROLE = "role"
    STATUS = "status"
    ACTIVITY = "activity"
    CREATED_AT = "created_at"


class GetUsersRequestTypedDict(TypedDict):
    pending: NotRequired[bool]
    r"""Whether to return pending users. **Default**: `false` (all users)

    """
    ids: NotRequired[List[str]]
    r"""A list of up to 100 user IDs.  When provided, other parameters are ignored."""
    emails: NotRequired[List[str]]
    r"""A list of up to 100 user Emails.  When provided, other parameters are ignored."""
    prefix: NotRequired[str]
    r"""Returns users where the name begins with the specified case-insensitive string."""
    sub_account_id: NotRequired[str]
    r"""Only returns users who have access to the specified account."""
    last_login: NotRequired[bool]
    r"""Specifies a date range for last login."""
    from_: NotRequired[date]
    r"""All last logins after this date, given in the format: yyyy-mm-dd.

    """
    to: NotRequired[date]
    r"""All last logins before this date, given in the format: yyyy-mm-dd.

    """
    union_type: NotRequired[UnionType]
    r"""Whether to return users who last logged in within the specified date range (include) or those who didn't
    last log in within the range (exclude). **Possible values**: `include`, `exclude`. **Default**: `include`.

    """
    sort_order: NotRequired[QueryParamSortOrder]
    r"""Control the order of returned users. **Possible values**: `desc` (default), `asc`.

    """
    sort_by: NotRequired[QueryParamSortBy]
    page: NotRequired[int]
    page_size: NotRequired[int]


class GetUsersRequest(BaseModel):
    pending: Annotated[
        Optional[bool],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Whether to return pending users. **Default**: `false` (all users)

    """

    ids: Annotated[
        Optional[List[str]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A list of up to 100 user IDs.  When provided, other parameters are ignored."""

    emails: Annotated[
        Optional[List[str]],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A list of up to 100 user Emails.  When provided, other parameters are ignored."""

    prefix: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Returns users where the name begins with the specified case-insensitive string."""

    sub_account_id: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Only returns users who have access to the specified account."""

    last_login: Annotated[
        Optional[bool],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Specifies a date range for last login."""

    from_: Annotated[
        Optional[date],
        pydantic.Field(alias="from"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""All last logins after this date, given in the format: yyyy-mm-dd.

    """

    to: Annotated[
        Optional[date],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""All last logins before this date, given in the format: yyyy-mm-dd.

    """

    union_type: Annotated[
        Optional[UnionType],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Whether to return users who last logged in within the specified date range (include) or those who didn't
    last log in within the range (exclude). **Possible values**: `include`, `exclude`. **Default**: `include`.

    """

    sort_order: Annotated[
        Optional[QueryParamSortOrder],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Control the order of returned users. **Possible values**: `desc` (default), `asc`.

    """

    sort_by: Annotated[
        Optional[QueryParamSortBy],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    page: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    page_size: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "pending",
                "ids",
                "emails",
                "prefix",
                "sub_account_id",
                "last_login",
                "from",
                "to",
                "union_type",
                "sort_order",
                "sort_by",
                "page",
                "page_size",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
